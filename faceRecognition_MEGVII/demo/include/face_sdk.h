#pragma once

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include "face_common.h"

#define FACE_API __attribute__((visibility("default")))

#ifdef __cplusplus
extern "C" {
#endif
/**
 * get sdk version and time
 * @return the string of (version_time)
 */
FACE_API const char* getVersion();

/**
 * set log level to print necessary information
 * @param logLevel LOG_LEVEL_ERROR and LOG_LEVEL_INFO
 * @return
 */
FACE_API FaceRetCode setLogLevel(Log_Level logLevel);

/**
 * initialize sdk with models. If you do not use a model, set its pointer to
 * null
 * @param[in]  FaceModels
 * @return     error code
 */
FACE_API FaceRetCode init(const FaceModels models);

/**
 * release sdk
 * @return     error code
 */
FACE_API FaceRetCode release();

/**
 * set detect config
 * @param[in]  detect_threshold         the interval [0, 1], detect face bbox
 * threshold
 * @param[in]  postfilter_threshold     the interval [0, 1], face landmark
 * postfilter threshold
 * @return     error code
 */
FACE_API FaceRetCode set_detect_config(const float detect_threshold,
                                       const float postfilter_threshold);

/**
 * detect faces from image
 * @param[in]  image      single image
 * @param[in]  face_within_thr the interval [0, 1], only reserve faces mostly
 * inside image
 * @param[in]  min_face_h  the minimum face height size in results
 * @param[out] faceHandleArr  Pre-allocated array to storage detected faces
 * @param[out] length     input array length, return number of detected faces
 * @return     error code
 */

FACE_API FaceRetCode detect(const Image* const image,
                            const float face_within_thr, const int min_face_h,
                            FaceHandle faceHandleArr[], int* length);

/**
 * detect and track faces from sequential frames
 * @param[in]  image      frame image
 * @param[in]  face_within_thr the interval [0, 1], only reserve faces mostly
 * inside image
 * @param[in]  min_face_h  the minimum face height size in results
 * @param[out] faceHandleArr  Pre-allocated array to storage detected faces
 * @param[out] length     input array length, return number of detected faces
 * @return     error code
 */
FACE_API FaceRetCode detectAndTrack(const Image* const image,
                                    const float face_within_thr,
                                    const int min_face_h,
                                    FaceHandle faceHandleArr[], int* length);

/**
 * get FaceRect with Facehandle
 * @param[in]  handle      the detected face handle
 * @param[out] result      face bounding box
 * @return     error code
 */
FACE_API FaceRetCode getFaceRect(const FaceHandle handle, FaceRect* result);

/**
 * get FaceLandmark with Facehandle
 * @param[in]  handle      the detected face handle
 * @param[out] result      pf landmark
 * @return     error code
 */
FACE_API FaceRetCode getFaceLandmark(const FaceHandle handle, Landmark* result);

/**
 * get track id from FaceHandle, which is generated by detectAndTrack interface
 * @param[in]  handle     the detected face handle
 * @param[out] track_id   the id of bounding box
 * @return     error code
 */
FACE_API FaceRetCode getTrackId(const FaceHandle handle, int* track_id);

/**
 * reset the tracker state, remove all tracks
 * @return     error code
 */
FACE_API FaceRetCode resetTrack();

/**
 * release detected face
 * @param[in]  handle           FaceHandle
 * @return     error code
 */
FACE_API FaceRetCode releaseFace(FaceHandle handle);

/**
 * get pose and blurness of detected face
 * @param[in]  image      single image
 * @param[in]  handle           the detected face handle
 * @param[out] pose_result      pose and blurness of the face
 * @return     error code
 */
FACE_API FaceRetCode getPoseBlurAttribute(const Image* const image,
                                          FaceHandle handle,
                                          FacePoseBlur* result);

/**
 * refine the pf landmark
 * @param[in]  image      single image
 * @param[in]  handle     the detected face handle
 * @param[out] result     the more precise landmark
 * @return     error code
 */
FACE_API FaceRetCode refineLandmark(const Image* const image, FaceHandle handle,
                                    Landmark* result);

/**
 * get the attribute of detected face
 * @param[in]  image      single image
 * @param[in]  handle     the detected face handle
 * @param[out] result     face attribute results
 * @return     error code
 */
FACE_API FaceRetCode getFaceAttrResult(const Image* const image,
                                       FaceHandle handle, FaceAttr* result);

/**
 * get the face occlusion attrubute
 * @param[in]  image      single image
 * @param[in]  handle     the detected face handle
 * @param[out] result     face area occlusion results
 * @return     error code
 */
FACE_API FaceRetCode getFaceOcclResult(const Image* const image,
                                       FaceHandle handle, FaceOccl* result);

/**
 * extract feature from the detected face
 * @param[in]  image      single image
 * @param[in]  handle                 face handle
 * @param[out] feature_result         feature array of detected face
 * @param[out] feature_length         the length of feature array
 * @return     error code
 */
FACE_API FaceRetCode extract(const Image* const image, FaceHandle handle,
                             char** feature_result, int* size);

/**
 * release feature
 * @param[in]  feature            the feature array of one face
 * @return     error code
 */
FACE_API FaceRetCode releaseFeature(const char* feature);

/**
 * get similarity of two features
 * @param[in]  first_feature      the feature array of one face
 * @param[in]  second_feature     the feature array of another face
 * @param[in]  feature_length     the length of feature array
 * @param[out] result             the similarity of two features (0-100]
 * @return     error code
 */
FACE_API FaceRetCode compare(const char* const first_feature,
                             const char* const second_feature,
                             const int feature_length, float* result);

/**
 * get rgb image liveness score of detected face
 * @param[in]  image      single image
 * @param[in]  handle			  visible face handle
 * @param[out] result             the interval [0, 1], liveness of face
 * @return     error code
 */
FACE_API FaceRetCode getLiveness_bgr(const Image* const image,
                                     FaceHandle handle, float* liveness_result);

/**
 * get ir image liveness score of detected face
 * @param[in]  image      single image
 * @param[in]  handle			 ir face handle
 * @param[out] result            the interval [0, 1], liveness of face
 * @return     error code
 */
FACE_API FaceRetCode getLiveness_ir(const Image* const image, FaceHandle handle,
                                    float* liveness_result);

/**
 * set if_filter parameter
 * @param[in]  x_k
 * @param[in]  x_b
 * @param[in]  y_k
 * @param[in]  y_b
 * @param[in]  overlap_rate  the interval [0.1, 0.9], the overlap rate threshold
 for ir detect rect and bgr detect rect, default 0.4, if two rects overlap_rate
 is larger than threshold, they are in pairs.
 * @return     error code
 */
FACE_API FaceRetCode set_match_config(const float x_k, const float x_b,
                                      const float y_k, const float y_b,
                                      const float overlap_rate);

/**
 * Match the visible handle array with the ir handle array
 * @param[in]  bgr_handle_array        	visible face handle array
 * @param[in]  ir_handle_array        ir face handles
 * @param[out] pair             record ir face index corresponding to every
 * visible light face, match pair: i->pair[i], or if pair[i] == ir_length is
 * attack;
 * @return     error code
 */
FACE_API FaceRetCode BGR_IR_match(FaceHandle* bgr_handle_array,
                                  const int length, FaceHandle* ir_handle_array,
                                  const int ir_length, int* pair);

/**
 * filter visible face array by corresponding ir face
 * @param[in]  bgr_handle_array        	visible face handle array
 * @param[in]  length    		number of visible faces
 * @param[in]  ir_handle_array        ir face handle array
 * @param[in]  ir_length     	number of ir faces
 * @param[out] filter_result    pointer to the result, 1 pass ir_filter, 0
 * failed ir_filter
 * @return     error code
 */
FACE_API FaceRetCode ir_filter(FaceHandle* bgr_handle_array, const int length,
                               FaceHandle* ir_handle_array, const int ir_length,
                               char* filter_result);

/**
 * set liveness_bgrir parameter
 * @param[in]  sreen_attack_thr  in the interval [0, 1], the screen attack
 filter threshold
 * @return     error code
 */
FACE_API FaceRetCode set_liveness_config(const float sreen_attack_thr);

/**
 * get visible and ir binocular liveness score of the detected face
 * @param[in]  bgr_image        visible image
 * @param[in]  bgr_handle		bgr handle
 * @param[in]  ir_image         ir image
 * @param[in]  ir_handle		ir handle
 * @param[out] result           the interval [0, 1], liveness of face
 * @return     error code
 */
FACE_API FaceRetCode getLiveness_bgrir(const Image* const bgr_image,
                                       FaceHandle bgr_handle,
                                       const Image* const ir_image,
                                       FaceHandle ir_handle,
                                       float* liveness_result);

/**
 * create a face group
 * @param[in]  handle			face group handle
 * @return     error code
 */
FACE_API FaceRetCode createFaceGroup(FaceGroupHandle* handle);

/**
 * insert a face into face group
 * @param[in]  handle               face group handle
 * @param[in]  feature              feature array of one face
 * @param[in]  feature_length       feature length
 * @param[in]  face_id              face id
 * @return     error code
 */
FACE_API FaceRetCode insertFaceGroup(FaceGroupHandle handle,
                                     const char* feature, int feature_length,
                                     uint64_t face_id);

/**
 * remove a face from face group
 * @param[in]  handle			Face Group Handle
 * @param[in]  face_id			face id of the face to be remove
 * @return     error code
 */
FACE_API FaceRetCode removeFaceGroup(FaceGroupHandle handle, uint64_t face_id);

/**
 * get the number of faces in group
 * @param[in]	handle				face group handle
 * @param[out]	total_sum			number of faces in group
 * @return		error code
 */
FACE_API FaceRetCode getFaceGroupCount(FaceGroupHandle handle,
                                       size_t* total_sum);

/**
 * clear all faces in the group
 * @param[in]	handle				face group handle
 * @return		error code
 */
FACE_API FaceRetCode resetFaceGroup(FaceGroupHandle handle);

/**
 * get most similar face id and similarity score from a face group
 * @param[in]  handle           face group handle
 * @param[in]  target           feature array of target face
 * @param[in]  feature_length   target feature length
 * @param[out] result           the interval (0, 100], similarity score
 * @param[out] idx              id of the most similar face
 * @return     error code
 */
FACE_API FaceRetCode identifyFromFaceGroup(FaceGroupHandle handle,
                                           const char* const target,
                                           const int feature_length,
                                           float* result, uint64_t* idx);

/**
 * get top k similar face ids and similarity scores from a face group, maximum
 * is 10
 * @param[in]  handle           face group handle
 * @param[in]  target           feature array of target face
 * @param[in]  feature_length   target feature length
 * @param[in]  k                how many results to return, in the interval [1,
 * 10].
 * @param[out] result           the interval (0, 100], similarity scores
 * @param[out] idx              ids of the top k similar faces
 * @return     error code
 */
FACE_API FaceRetCode top_k_FromFaceGroup(FaceGroupHandle handle,
                                         const char* target,
                                         const int feature_length, const int k,
                                         float* result, uint64_t* idx);

/**
 * release a group
 * @param[in]	handle          face group handle
 * @return		error code
 */
FACE_API FaceRetCode releaseFaceGroup(FaceGroupHandle handle);

#ifdef __cplusplus
}
#endif
